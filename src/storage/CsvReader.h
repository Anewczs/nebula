/*
 * Copyright 2017-present Shawn Cao
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <folly/Conv.h>
#include <folly/String.h>
#include <fstream>
#include <iostream>
#include <string>
#include <unordered_map>
#include "common/Errors.h"
#include "surface/DataSurface.h"

/**
 * A wrapper for interacting with AWS / S3
 */
namespace nebula {
namespace storage {

class CsvRow : public nebula::surface::RowData {
public:
  CsvRow() = default;
  CsvRow(const std::vector<std::string>& data, const std::function<size_t(const std::string&)>& columnLookup)
    : data_{ data }, columnLookup_{ columnLookup } {};
  virtual ~CsvRow() = default;

  bool isNull(const std::string&) const override {
    // TODO(cao) - CSV reader doesn't produce null valus for now
    return false;
  }

#define CONV_TYPE_INDEX(TYPE, FUNC)                    \
  TYPE FUNC(const std::string& field) const override { \
    auto index = columnLookup_(field);                 \
    return folly::to<TYPE>(data_.at(index));           \
  }

  CONV_TYPE_INDEX(bool, readBool)
  CONV_TYPE_INDEX(int8_t, readByte)
  CONV_TYPE_INDEX(int16_t, readShort)
  CONV_TYPE_INDEX(int32_t, readInt)
  CONV_TYPE_INDEX(int64_t, readLong)
  CONV_TYPE_INDEX(float, readFloat)
  CONV_TYPE_INDEX(double, readDouble)
  CONV_TYPE_INDEX(std::string, readString)

#undef CONV_TYPE_INDEX

  // compound types
  std::unique_ptr<nebula::surface::ListData> readList(const std::string&) const override {
    throw NException("Array not supported yet.");
  }

  std::unique_ptr<nebula::surface::MapData> readMap(const std::string&) const override {
    throw NException("Map not supported yet.");
  }

public:
  void readNext(std::istream& str) {
    std::string line;
    std::getline(str, line);

    std::stringstream lineStream(line);
    std::string cell;

    data_.clear();
    while (std::getline(lineStream, cell, ',')) {
      data_.push_back(folly::trimWhitespace(cell).toString());
    }

    // This checks for a trailing comma with no data after it.
    if (!lineStream && cell.empty()) {
      // If there was a trailing comma then add an empty element.
      data_.push_back("");
    }
  }

  inline const std::vector<std::string>& rawData() const {
    return data_;
  }

private:
  // reference a line generated by reader
  std::vector<std::string> data_;
  std::function<size_t(std::string)> columnLookup_;
};

std::istream& operator>>(std::istream& str, CsvRow& data) {
  data.readNext(str);
  return str;
}

class CsvReader : public nebula::common::Cursor<nebula::surface::RowData> {
  using Base = nebula::common::Cursor<nebula::surface::RowData>;

public:
  CsvReader(const std::string& file)
    : Base(0), fstream_{ file } {
    // read header - required
    if (fstream_ >> row_) {
      // row_ has headers - build the name-index mapping
      const auto& raw = row_.rawData();
      for (size_t i = 0, size = raw.size(); i < size; ++i) {
        columns_[raw.at(i)] = i;
      }
    }

    // read one row
    if (fstream_ >> row_) {
      size_ = 1;
    }
  }

  virtual ~CsvReader() = default;

  // next row data of CsvRow
  virtual const nebula::surface::RowData& next() override {
    // consume a row and read a new row
    cacheRow_ = CsvRow(row_.rawData(), [this](const std::string& name) -> size_t {
      return columns_.at(name);
    });

    // read next row
    if (fstream_ >> row_ && row_.rawData().size() >= columns_.size()) {
      size_ += 1;
    }

    index_++;
    return cacheRow_;
  }

private:
  std::ifstream fstream_;
  CsvRow row_;
  CsvRow cacheRow_;
  std::unordered_map<std::string, size_t> columns_;
};

} // namespace storage
} // namespace nebula